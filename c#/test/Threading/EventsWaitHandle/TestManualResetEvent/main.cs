using System;
using System.Threading;

public class Example
{
	// mre is used to block and release threads manually. It is
	// created in the unsignaled state.
	private static ManualResetEvent mre = new ManualResetEvent(false);

	static void Main()
	{
		Console.WriteLine("\nStart 3 named threads that block on a ManualResetEvent:\n");

		for (int i = 0; i <= 2; i++)
		{
			Thread t = new Thread(ThreadProc);
			t.Name = "Thread_" + i;
			t.Start();
		}
		
		Thread.Sleep(500);
		Console.WriteLine("\nWhen all three threads have started, press Enter to call Set()" +
						  "\nto release all the threads.\n");
		Console.ReadLine();

		mre.Set();
		
		Thread.Sleep(500);
		Console.WriteLine("\nWhen a ManualResetEvent is signaled, threads that call WaitOne()" +
						  "\ndo not block. Press Enter to show this.\n");
		Console.ReadLine();

		for (int i = 3; i <= 4; i++)
		{
			Thread t = new Thread(ThreadProc);
			t.Name = "Thread_" + i;
			t.Start();
		}

		Thread.Sleep(500);
		Console.WriteLine("\nPress Enter to call Reset(), so that threads once again block" +
						  "\nwhen they call WaitOne().\n");
		Console.ReadLine();
		
		mre.Reset();

		// Start a thread that waits on the ManualResetEvent.
		Thread t5 = new Thread(ThreadProc);
		t5.Name = "Thread_5";
		t5.Start();

		Thread.Sleep(500);
		Console.WriteLine("\nPress Enter to call Set() and conclude the demo.");
		Console.ReadLine();

		mre.Set();
		
		Console.ReadLine();
	}


	private static void ThreadProc()
	{
		string name = Thread.CurrentThread.Name;

		Console.WriteLine(name + " starts and calls mre.WaitOne()");

		mre.WaitOne();

		Console.WriteLine(name + " ends.");
	}
}